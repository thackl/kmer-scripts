#!/usr/bin/env perl
use warnings;
use strict;

use Pod::Usage;
use Getopt::Long;
use Log::Log4perl qw(:no_extra_logdie_message);
use Log::Log4perl::Level;
use File::Temp 'tempdir';

use Kmer;
use Jellyfish;
use Fasta::Parser;
use Fastq::Parser;

use threads;
use Thread::Queue;

use Data::Dumper;

our $VERSION = "0.3.0";

=head1 NAME

kmer-coverage

=head1 AUTHOR

Thomas Hackl - S<thackl@lim4.de>

=head1 SYNOPSIS

  $ pv <READS.f[aq]> | kmer-coverage -j <JELLYFISH HASH>  > READS.cov

=head1 OPTIONS

=over 25

=item -j|--jf=<file>

Path to the jellyfish kmer hash file.

=item -L|--no-load [OFF]

Disable preloading of hash into memory, recommended for small queries or
subsequent runs on same hash (already mapped to memory).

=item [--help]

Show help

=item [--debug]

=back

Output: one line per read, 3 fields (id, median count, per-base counts) tab separated, counts space separated

  read1   120   1034 1223 1212 1234 1002 878 676 424 ...
  read2   56    68 54 48 44 56 ...

=head1 CODE

=cut

my %opt = init();
my $L = $opt{logger};

my $fp;
my $is_fastq;
# try fastq;
if($fp = Fastq::Parser->new(fh => $opt{ifh})->check_format){
    $is_fastq = 1;
}elsif($fp = Fasta::Parser->new(fh => $opt{ifh})->check_format){
    $is_fastq = 0;
}else{
    $L->logdie("--in $opt{in} neither FASTQ nor FASTA");
}

# in thread and with $jf->get_kmer_size
# auto-detect hash kmer size
#my $jf_info = $jf->run(['info', '--json', $opt{'jf'}]);
#$jf_info =~ m/"key_len" : (\d+)/s;
#$opt{'kmer_size'} = $1/2;

# load hash
unless ($opt{no_load}) {
    $L->info("loading jellyfish hash");
    qx(cat $opt{jf} > /dev/null);
}

my $Qw = Thread::Queue->new();
my $Qo = Thread::Queue->new();

my $tmp = tempdir(
    "kmer-coverage-XXXXXX",
    DIR => $opt{tmp},
    CLEANUP => 1,#1 #$opt{keep} ? 0 : 1,
);

my $jf = Jellyfish->new();
my $ks = $jf->get_kmer_size([$opt{jf}]);
# my $kh = Kmer->new(kmer_size => $ks);

if ($opt{adjust}) {
    $L->info("computing adjustment hash");
    qx(jellyfish count -s 10M -m $ks -o $tmp/adjust.jf $opt{in});
    $opt{jfa} = "$tmp/adjust.jf";
}


my @thread_worker = map{
    threads->create(\&thread_worker)
} 1..$opt{threads};
# launch output thread
my $thread_out = threads->create(\&thread_out);

$L->info("processing sequences");
my $i=-1;
while(1){
    if ( $Qw->pending > $opt{threads}+2){
        sleep 1; next;
    };

    $L->debug("# pending: ", $Qw->pending,"\n");
    my @fbin;
    my $flen = 0;
    my $eof = 1;
    while (my $fs = $fp->next_seq){
        push @fbin, $fs;
        $flen += length($fs->seq);
        if ($flen > $opt{chunk_size}){
            $eof=0;
            last;
        }
    }

    $L->debug("# chunk: ".@fbin." $flen $opt{chunk_size}\n");
    $Qw->enqueue(++$i, \@fbin);
    last if $eof; # eof
}

# all jobs submitted
$Qw->end;
$_->join for @thread_worker;

# all workers done, close Result queue;
$Qo->end;
$thread_out->join;

$L->info("done");

##- Methods ------------------------------------------------------------------##

=head1 Methods

=cut

sub output_job{
    my ($covs) = @_;
    foreach my $k ( @$covs) {
        print $k,"\n";
    }
}



## methods
sub thread_worker{
    my $tid = threads->tid();
    $L->debug("# launched t$tid\n");
    my $tfa = "$tmp/$tid.fa";

    while (1){
        my ($j, $fbin) = $Qw->dequeue(2);
        return unless defined $j; # no more work

        my @knum;
        open(TMP, '>', $tfa) or die $!;
        foreach my $fs (@$fbin) {
            print TMP $fs;
            push @knum, length($fs->seq) - $ks + 1;
        }
        close TMP;

        $L->debug("# t$tid j$j\n");
        # process $c
        my @covs;
        if ($opt{adjust}) {
            open(JF, "jellyfish query -s $tfa $opt{jf} | cut -d' ' -f2 |") or die $!;
            open(JFA, "jellyfish query -s $tfa $opt{jfa} | cut -d' ' -f2 |") or die $!;
            for (my $j=0; $j<@knum; $j++) {
                my $cs = '';
                my %cmed;
                for (my $i=0; $i<$knum[$j]; $i++) {
                    my $ct = <JF>;
                    my $ca = <JFA>;
                    chomp($ct);
                    chomp($ca);
                    my $c = int(($ct/$ca)+.5);
                    $cmed{$c}++;
                    $cs.= $c." ";
                }
                chop($cs);
                push @covs, $fbin->[$j]->id()."\t".hist_med(\%cmed)."\t".hist_repr_anscombe(\%cmed)."\t".$cs;
            }
        } else {
            open(JF, "jellyfish query -s $tfa $opt{jf} | cut -d' ' -f2 |") or die $!;
            for (my $j=0; $j<@knum; $j++) {
                my $cs = '';
                my %cmed;
                for (my $i=0; $i<$knum[$j]; $i++) {
                    my $c = <JF>;
                    chomp($c);
                    $cmed{$c}++;
                    $cs.=$c." ";
                }
                chop($cs);
                push @covs, $fbin->[$j]->id()."\t".hist_med(\%cmed)."\t".hist_repr_anscombe(\%cmed)."\t".$cs;
            }
        }

        # enqueue result
        $Qo->enqueue($j, \@covs);
    }
}


sub thread_out{
    my $tid = threads->tid();
    my %buf;
    my $jout = 0;
    while (1){
        my ($j, $c) = $Qo->dequeue(2);
        unless (defined $j){ # no more work
            # emtpy buffer
            die "Incomplete output from threads\n" if %buf;
            last;
        }

        $L->debug("# $c $j ($jout)\n");

        if ($j == $jout) {
            output_job($c, $j);
            while (exists $buf{++$jout}) { # look ahead in buffer
                output_job($buf{$jout}, $jout, 1);
                delete $buf{$jout};
            }
        }else {
            $buf{$j} = $c;
        }
    }
}



=head2 init

=cut

sub init{
    no warnings 'qw';

    my (%p) = @_;

    # GetOptions
    my $argv = join(" ", @ARGV);

    # logger
    Log::Log4perl->init( \(q(
        log4perl.rootLogger                     = INFO, Screen
        log4perl.appender.Screen                = Log::Log4perl::Appender::Screen
        log4perl.appender.Screen.stderr         = 1
        log4perl.appender.Screen.layout         = PatternLayout
        log4perl.appender.Screen.layout.ConversionPattern = [%d{yy-MM-dd HH:mm:ss}] [kmer-coverage] %m%n)));

    my %def = ();
    my %opt = (
        threads => 1,
        tmp => (-d '/dev/shm' ? '/dev/shm' : '/tmp'),
        chunk_size => 5_000_000,
    );
    my $L = $opt{logger} = Log::Log4perl->get_logger();

    GetOptions(
        \%opt, qw(
                     jf|j=s
                     in|reads=s
                     tmp=s
                     adjust!
                     no_load|no-load|L!
                     threads|t=i
                     version|V!
                     debug|D!
                     help|h!
             )
    ) or $L->logdie('Failed to "GetOptions"');

    $opt{argv} = $argv; # store it just in case

    # help
    $opt{help} && pod2usage(1);

    # version
    if ($opt{version}) {
        print"$VERSION\n";
        exit 0;
    }

    $opt{in} = @ARGV ? shift @ARGV : '-';

    $L->logdie("unused argument: @ARGV") if @ARGV;

    %opt = (%def, %opt);

    # required stuff
    for (qw(jf)) {
        if (ref $opt{$_} eq 'ARRAY') {
            pod2usage("required: --$_") unless @{$opt{$_}}
        } else {
            pod2usage("required: --$_") unless defined ($opt{$_})
        }
    }

    if ($opt{in} ne '-') {
        open($opt{ifh}, '<', $opt{in}) or $L->logdie;
    } else {
        $L->info("reading STDIN");
        $opt{in} = \*STDIN;
    }
    # debug level
    $L->level($DEBUG) if $opt{debug};
    $L->debug('Verbose level set to DEBUG');

    $L->debug(Dumper(\%opt));

    return %opt;
}
